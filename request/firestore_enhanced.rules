rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for authentication and authorization
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function getUserId() {
      return request.auth.uid;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(getUserId())).data;
    }
    
    function hasRole(role) {
      return isAuthenticated() && role in getUserData().roles;
    }
    
    function isRoleVerified(role) {
      return hasRole(role) && 
             getUserData().roleData[role].verificationStatus == 'approved';
    }
    
    function isOwnerOrAdmin(resourceUserId) {
      return getUserId() == resourceUserId || hasRole('admin');
    }
    
    function isValidEmail(email) {
      return email is string && email.matches('.*@.*\\..*');
    }
    
    function isValidPhoneNumber(phone) {
      return phone is string && phone.matches('\\+[1-9]\\d{1,14}');
    }
    
    // Phone verification requirement for requests and responses
    function hasVerifiedPhone() {
      return getUserData().isPhoneVerified == true && 
             getUserData().phoneNumber != null &&
             getUserData().phoneNumber != '';
    }
    
    // Users collection rules
    match /users/{userId} {
      // Allow read access to own profile or public profile data
      allow read: if getUserId() == userId || 
                     (isAuthenticated() && 
                      resource.data.isPublic == true);
      
      // Allow creation only during registration
      allow create: if getUserId() == userId &&
                       isValidUserCreation();
      
      // Allow updates to own profile with validation
      allow update: if getUserId() == userId &&
                       isValidUserUpdate();
      
      // Only allow deletion of own account
      allow delete: if getUserId() == userId;
      
      // Validation functions for user data
      function isValidUserCreation() {
        let newData = request.resource.data;
        return newData.keys().hasAll(['id', 'name', 'email', 'roles', 'activeRole', 
                                     'roleData', 'createdAt', 'updatedAt']) &&
               newData.id == userId &&
               newData.name is string &&
               newData.name.size() > 0 &&
               (newData.email == '' || isValidEmail(newData.email)) &&
               (newData.phoneNumber == null || isValidPhoneNumber(newData.phoneNumber)) &&
               newData.roles is list &&
               newData.roles.size() > 0 &&
               newData.activeRole in newData.roles &&
               newData.roleData is map &&
               newData.createdAt is timestamp &&
               newData.updatedAt is timestamp;
      }
      
      function isValidUserUpdate() {
        let newData = request.resource.data;
        let oldData = resource.data;
        
        // Prevent changing immutable fields
        return newData.id == oldData.id &&
               newData.createdAt == oldData.createdAt &&
               // Allow email/phone updates only if verified or admin
               (newData.email == oldData.email || 
                isRoleVerified('admin') || 
                !oldData.isEmailVerified) &&
               (newData.phoneNumber == oldData.phoneNumber || 
                isRoleVerified('admin') || 
                !oldData.isPhoneVerified) &&
               // Validate role changes
               isValidRoleUpdate(oldData.roles, newData.roles, oldData.roleData, newData.roleData) &&
               newData.updatedAt is timestamp;
      }
      
      function isValidRoleUpdate(oldRoles, newRoles, oldRoleData, newRoleData) {
        // Can only add roles, not remove (unless admin)
        return (hasRole('admin') || 
                oldRoles.toSet().difference(newRoles.toSet()).size() == 0) &&
               // New roles must have corresponding role data
               newRoles.toSet().difference(newRoleData.keys().toSet()).size() == 0;
      }
    }
    
    // Requests collection rules - REQUIRES VERIFIED PHONE
    match /requests/{requestId} {
      // Public requests are readable by authenticated users with verified phone
      allow read: if isAuthenticated() && 
                     hasVerifiedPhone() &&
                     (resource.data.isPublic == true || 
                      resource.data.requesterId == getUserId() ||
                      resource.data.assignedTo == getUserId());
      
      // Only authenticated users with verified phone can create requests
      allow create: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       isValidRequestCreation();
      
      // Only request owner with verified phone can update their requests
      allow update: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       resource.data.requesterId == getUserId() &&
                       isValidRequestUpdate();
      
      // Only request owner or admin can delete
      allow delete: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       (resource.data.requesterId == getUserId() || 
                        hasRole('admin'));
      
      function isValidRequestCreation() {
        let newData = request.resource.data;
        return newData.requesterId == getUserId() &&
               newData.title is string &&
               newData.title.size() > 0 &&
               newData.description is string &&
               newData.type in ['item', 'service', 'ride', 'delivery', 'rental', 'price'] &&
               newData.status == 'draft' &&
               newData.createdAt is timestamp &&
               newData.updatedAt is timestamp;
      }
      
      function isValidRequestUpdate() {
        let newData = request.resource.data;
        let oldData = resource.data;
        
        // Prevent changing immutable fields
        return newData.id == oldData.id &&
               newData.requesterId == oldData.requesterId &&
               newData.createdAt == oldData.createdAt &&
               newData.type == oldData.type &&
               newData.updatedAt is timestamp;
      }
    }
    
    // Responses collection rules - REQUIRES VERIFIED PHONE
    match /responses/{responseId} {
      // Responses are readable by request owner and responder (both need verified phone)
      allow read: if isAuthenticated() &&
                     hasVerifiedPhone() &&
                     (resource.data.responderId == getUserId() ||
                      get(/databases/$(database)/documents/requests/$(resource.data.requestId)).data.requesterId == getUserId());
      
      // Only authenticated users with verified phone can create responses (not to own requests)
      allow create: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       isValidResponseCreation();
      
      // Only responder with verified phone can update their responses
      allow update: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       resource.data.responderId == getUserId() &&
                       isValidResponseUpdate();
      
      // Only responder or request owner can delete
      allow delete: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       (resource.data.responderId == getUserId() ||
                        get(/databases/$(database)/documents/requests/$(resource.data.requestId)).data.requesterId == getUserId());
      
      function isValidResponseCreation() {
        let newData = request.resource.data;
        let requestData = get(/databases/$(database)/documents/requests/$(newData.requestId)).data;
        
        return newData.responderId == getUserId() &&
               requestData.requesterId != getUserId() && // Can't respond to own request
               requestData.status == 'active' &&
               newData.message is string &&
               newData.message.size() > 0 &&
               newData.createdAt is timestamp;
      }
      
      function isValidResponseUpdate() {
        let newData = request.resource.data;
        let oldData = resource.data;
        
        // Prevent changing immutable fields
        return newData.id == oldData.id &&
               newData.requestId == oldData.requestId &&
               newData.responderId == oldData.responderId &&
               newData.createdAt == oldData.createdAt;
      }
    }
    
    // Messages collection for in-app messaging - REQUIRES VERIFIED PHONE
    match /messages/{messageId} {
      // Messages are readable by sender and receiver (both need verified phone)
      allow read: if isAuthenticated() &&
                     hasVerifiedPhone() &&
                     (resource.data.senderId == getUserId() ||
                      resource.data.receiverId == getUserId());
      
      // Only authenticated users with verified phone can send messages
      allow create: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       request.resource.data.senderId == getUserId() &&
                       request.resource.data.receiverId != getUserId() &&
                       request.resource.data.content is string &&
                       request.resource.data.content.size() > 0;
      
      // Messages are immutable once created
      allow update: if false;
      allow delete: if false;
    }
    
    // Verification documents for role verification
    match /verifications/{verificationId} {
      // Only the user and admins can read verification documents
      allow read: if isAuthenticated() &&
                     (resource.data.userId == getUserId() ||
                      hasRole('admin'));
      
      // Users can create verification requests
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == getUserId() &&
                       isValidVerificationCreation();
      
      // Only admins can update verification status
      allow update: if hasRole('admin') &&
                       isValidVerificationUpdate();
      
      // Only the user can delete their verification request
      allow delete: if isAuthenticated() &&
                       resource.data.userId == getUserId();
      
      function isValidVerificationCreation() {
        let newData = request.resource.data;
        return newData.status == 'pending' &&
               newData.role in ['driver', 'delivery', 'business'] &&
               newData.submittedAt is timestamp;
      }
      
      function isValidVerificationUpdate() {
        let newData = request.resource.data;
        let oldData = resource.data;
        
        return oldData.userId == newData.userId &&
               oldData.role == newData.role &&
               newData.status in ['pending', 'approved', 'rejected'] &&
               newData.reviewedAt is timestamp;
      }
    }
    
    // Analytics and reporting (admin only)
    match /analytics/{document=**} {
      allow read, write: if hasRole('admin');
    }
    
    // System configurations (admin only)
    match /config/{document=**} {
      allow read: if isAuthenticated();
      allow write: if hasRole('admin');
    }
    
    // Allow backward compatibility for existing collections during migration
    match /drivers/{document=**} {
      allow read, write: if isAuthenticated();
    }
    
    match /{collection}/{document=**} {
      allow read, write: if isAuthenticated() && 
                            collection in ['activities', 'brands', 'business_products', 'business_verifications',
                                         'businesses', 'categories', 'conversations', 'custom_product_variables',
                                         'email_otp_verifications', 'master_products', 'notifications', 
                                         'phone_otp_verifications', 'phone_verifications', 'product_colors',
                                         'rentalresponses', 'response_tracking', 'ride_tracking', 
                                         'subcategories', 'test', 'verification_audit_log'];
    }
  }
}
