rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for authentication and authorization
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function getUserId() {
      return request.auth.uid;
    }
    
    // Safe function to get user data that doesn't fail if doc doesn't exist
    function getUserDataSafe() {
      return isAuthenticated() && exists(/databases/$(database)/documents/users/$(getUserId())) 
             ? get(/databases/$(database)/documents/users/$(getUserId())).data 
             : {};
    }
    
    function hasRole(role) {
      let userData = getUserDataSafe();
      return isAuthenticated() && 'roles' in userData && role in userData.roles;
    }
    
    function isRoleVerified(role) {
      let userData = getUserDataSafe();
      return hasRole(role) && 
             'roleData' in userData &&
             role in userData.roleData &&
             userData.roleData[role].verificationStatus == 'approved';
    }
    
    function isOwnerOrAdmin(resourceUserId) {
      return getUserId() == resourceUserId || hasRole('admin');
    }
    
    function isValidEmail(email) {
      return email is string && email.matches('.*@.*\\..*');
    }
    
    function isValidPhoneNumber(phone) {
      return phone is string && phone.matches('\\+[1-9]\\d{1,14}');
    }
    
    // Phone verification requirement for requests and responses (safe version)
    function hasVerifiedPhone() {
      let userData = getUserDataSafe();
      return 'isPhoneVerified' in userData && 
             userData.isPhoneVerified == true && 
             'phoneNumber' in userData &&
             userData.phoneNumber != null &&
             userData.phoneNumber != '';
    }
    
    // ========================================
    // TEST COLLECTION FOR DEBUGGING
    // ========================================
    
    // Allow test collection for debugging connectivity
    match /test/{document=**} {
      allow read, write: if isAuthenticated();
    }

    // ========================================
    // TEMPORARY ADMIN ACCESS FOR DEBUGGING
    // ========================================
    
    // Users collection rules - simplified for authentication
    match /users/{userId} {
      // Allow read access to own profile or if authenticated
      allow read: if getUserId() == userId || isAuthenticated();
      
      // Allow creation during registration
      allow create: if getUserId() == userId;
      
      // Allow updates to own profile
      allow update: if getUserId() == userId;
      
      // Allow deletion of own account
      allow delete: if getUserId() == userId;
      
      // Validation functions for user data
      function isValidUserCreation() {
        let newData = request.resource.data;
        return newData.keys().hasAll(['id', 'name', 'email', 'roles', 'activeRole', 
                                     'roleData', 'createdAt', 'updatedAt']) &&
               newData.id == userId &&
               newData.name is string &&
               newData.name.size() > 0 &&
               (newData.email == '' || isValidEmail(newData.email)) &&
               (newData.phoneNumber == null || isValidPhoneNumber(newData.phoneNumber)) &&
               newData.roles is list &&
               newData.roles.size() > 0 &&
               newData.activeRole in newData.roles &&
               newData.roleData is map &&
               newData.createdAt is timestamp &&
               newData.updatedAt is timestamp;
      }
      
      function isValidUserUpdate() {
        let newData = request.resource.data;
        let oldData = resource.data;
        
        // Prevent changing immutable fields
        return newData.id == oldData.id &&
               newData.createdAt == oldData.createdAt &&
               // Allow email/phone updates only if verified or admin
               (newData.email == oldData.email || 
                isRoleVerified('admin') || 
                !oldData.isEmailVerified) &&
               (newData.phoneNumber == oldData.phoneNumber || 
                isRoleVerified('admin') || 
                !oldData.isPhoneVerified) &&
               // Validate role changes
               isValidRoleUpdate(oldData.roles, newData.roles, oldData.roleData, newData.roleData) &&
               newData.updatedAt is timestamp;
      }
      
      function isValidRoleUpdate(oldRoles, newRoles, oldRoleData, newRoleData) {
        // Can only add roles, not remove (unless admin)
        return (hasRole('admin') || 
                oldRoles.toSet().difference(newRoles.toSet()).size() == 0) &&
               // New roles must have corresponding role data
               newRoles.toSet().difference(newRoleData.keys().toSet()).size() == 0;
      }
    }
    
    // Requests collection rules - DEVELOPMENT VERSION (More permissive)
    match /requests/{requestId} {
      // Public requests are readable by authenticated users (removed phone verification requirement)
      allow read: if isAuthenticated() &&
                     (resource.data.isPublic == true || 
                      resource.data.requesterId == getUserId() ||
                      resource.data.assignedTo == getUserId());
      
      // Only authenticated users can create requests (removed phone verification requirement)
      allow create: if isAuthenticated() &&
                       isValidRequestCreation();
      
      // Only request owner can update their requests (removed phone verification requirement)
      allow update: if isAuthenticated() &&
                       resource.data.requesterId == getUserId() &&
                       isValidRequestUpdate();
      
      // Only request owner or admin can delete
      allow delete: if isAuthenticated() &&
                       (resource.data.requesterId == getUserId() || 
                        hasRole('admin'));
      
      function isValidRequestCreation() {
        let newData = request.resource.data;
        return newData.requesterId == getUserId() &&
               newData.title is string &&
               newData.title.size() > 0 &&
               newData.description is string &&
               newData.type in ['item', 'service', 'ride', 'delivery', 'rental', 'price'] &&
               newData.status == 'draft' &&
               newData.createdAt is timestamp &&
               newData.updatedAt is timestamp;
      }
      
      function isValidRequestUpdate() {
        let newData = request.resource.data;
        let oldData = resource.data;
        
        // Prevent changing immutable fields
        return newData.id == oldData.id &&
               newData.requesterId == oldData.requesterId &&
               newData.createdAt == oldData.createdAt &&
               newData.type == oldData.type &&
               newData.updatedAt is timestamp;
      }
    }
    
    // Allow admin panel to read and update businesses collection
    match /businesses/{document=**} {
      allow read, write: if true;  // Temporary for admin debugging
    }
    
    // Allow unified OTP system collections
    match /unified_otp_verifications/{document=**} {
      allow read, write: if request.auth != null;  // Allow authenticated users to use OTP system
    }
    
    match /verification_audit_log/{document=**} {
      allow read, write: if request.auth != null;  // Allow authenticated users to create verification logs
    }
    
    // Allow admin panel to read and update categories collection
    match /categories/{document=**} {
      allow read, write: if true;  // Allow unauthenticated access for admin panel
    }
    
    // Allow admin panel to read and update products collections
    match /master_products/{document=**} {
      allow read, write: if true;  // Temporary for admin debugging
    }
    
    match /business_products/{document=**} {
      allow read, write: if true;  // Temporary for admin debugging
    }
    
    match /product_categories/{document=**} {
      allow read, write: if true;  // Temporary for admin debugging
    }
    
    // Allow admin panel to read and update brands collection
    match /brands/{document=**} {
      allow read, write: if true;  // Allow unauthenticated access for admin panel
    }
    
    // Allow admin panel to read and update subcategories collection
    match /subcategories/{document=**} {
      allow read, write: if true;  // Allow unauthenticated access for admin panel
    }
    
    // Allow admin panel to read and update product variables collections
    match /product_colors/{document=**} {
      allow read, write: if true;  // Allow unauthenticated access for admin panel
    }
    
    match /product_sizes/{document=**} {
      allow read, write: if true;  // Allow unauthenticated access for admin panel
    }
    
    match /product_materials/{document=**} {
      allow read, write: if true;  // Allow unauthenticated access for admin panel
    }
    
    match /custom_product_variables/{document=**} {
      allow read, write: if true;  // Allow unauthenticated access for admin panel
    }
    
    // Allow authenticated users to read product variables for business products
    match /productVariables/{document=**} {
      allow read: if true;  // Allow all reads for product variables
      allow write: if true;  // Allow admin panel to write product variables
    }

    // Temporary admin access for debugging (REMOVE IN PRODUCTION!)
    // Allow read access to drivers collection for admin panel
    match /drivers/{document=**} {
      allow read, write: if true;  // Temporary for admin debugging - allow updates
    }

    // Responses collection rules - REQUIRES VERIFIED PHONE
    match /responses/{responseId} {
      // Responses are readable by request owner and responder (both need verified phone)
      allow read: if isAuthenticated() &&
                     hasVerifiedPhone() &&
                     (resource.data.responderId == getUserId() ||
                      get(/databases/$(database)/documents/requests/$(resource.data.requestId)).data.requesterId == getUserId());
      
      // Only authenticated users with verified phone can create responses (not to own requests)
      allow create: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       isValidResponseCreation();
      
      // Only responder with verified phone can update their responses
      allow update: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       resource.data.responderId == getUserId() &&
                       isValidResponseUpdate();
      
      // Only responder or request owner can delete
      allow delete: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       (resource.data.responderId == getUserId() ||
                        get(/databases/$(database)/documents/requests/$(resource.data.requestId)).data.requesterId == getUserId());
      
      function isValidResponseCreation() {
        let newData = request.resource.data;
        let requestData = get(/databases/$(database)/documents/requests/$(newData.requestId)).data;
        
        return newData.responderId == getUserId() &&
               requestData.requesterId != getUserId() && // Can't respond to own request
               requestData.status == 'active' &&
               newData.message is string &&
               newData.message.size() > 0 &&
               newData.createdAt is timestamp;
      }
      
      function isValidResponseUpdate() {
        let newData = request.resource.data;
        let oldData = resource.data;
        
        // Prevent changing immutable fields
        return newData.id == oldData.id &&
               newData.requestId == oldData.requestId &&
               newData.responderId == oldData.responderId &&
               newData.createdAt == oldData.createdAt;
      }
    }
    
    // Messages collection for in-app messaging - REQUIRES VERIFIED PHONE
    match /messages/{messageId} {
      // Messages are readable by sender and receiver (both need verified phone)
      allow read: if isAuthenticated() &&
                     hasVerifiedPhone() &&
                     (resource.data.senderId == getUserId() ||
                      resource.data.receiverId == getUserId());
      
      // Only authenticated users with verified phone can send messages
      allow create: if isAuthenticated() &&
                       hasVerifiedPhone() &&
                       request.resource.data.senderId == getUserId() &&
                       request.resource.data.receiverId != getUserId() &&
                       request.resource.data.content is string &&
                       request.resource.data.content.size() > 0;
      
      // Messages are immutable once created
      allow update: if false;
      allow delete: if false;
    }
    
    // Verification documents for role verification
    match /verifications/{verificationId} {
      // Only the user and admins can read verification documents
      allow read: if isAuthenticated() &&
                     (resource.data.userId == getUserId() ||
                      hasRole('admin'));
      
      // Users can create verification requests
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == getUserId() &&
                       isValidVerificationCreation();
      
      // Only admins can update verification status
      allow update: if hasRole('admin') &&
                       isValidVerificationUpdate();
      
      // Only the user can delete their verification request
      allow delete: if isAuthenticated() &&
                       resource.data.userId == getUserId();
      
      function isValidVerificationCreation() {
        let newData = request.resource.data;
        return newData.status == 'pending' &&
               newData.role in ['driver', 'delivery', 'business'] &&
               newData.submittedAt is timestamp;
      }
      
      function isValidVerificationUpdate() {
        let newData = request.resource.data;
        let oldData = resource.data;
        
        return oldData.userId == newData.userId &&
               oldData.role == newData.role &&
               newData.status in ['pending', 'approved', 'rejected'] &&
               newData.reviewedAt is timestamp;
      }
    }
    
    // Enhanced admin-only collections
    match /analytics/{document=**} {
      allow read, write: if hasRole('admin');
    }
    
    match /config/{document=**} {
      allow read: if isAuthenticated();
      allow write: if hasRole('admin');
    }

    // Phone verification collection
    match /phone_verifications/{verificationId} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null;
    }

    // Phone OTP verifications collection for custom OTP system
    match /phone_otp_verifications/{otpId} {
      // Allow authenticated users to create and read their own OTP records
      // The otpId format is: ${userId}_${phoneNumber}
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId &&
        otpId.matches('^' + request.auth.uid + '_.*');
      allow read, update, delete: if request.auth != null && 
        request.auth.uid == resource.data.userId &&
        otpId.matches('^' + request.auth.uid + '_.*');
    }

    // Email OTP verifications collection for email verification
    match /email_otp_verifications/{email} {
      // Allow anyone to create OTP records (for registration)
      // Allow reading/updating only for email verification process
      allow create, read, update: if true;
      allow delete: if request.auth != null;
    }

    // Email OTP verifications collection for email OTP system
    match /email_otp_verifications/{email} {
      // Allow anyone to create, read, update email OTP records (for registration flow)
      // This is needed for email verification during user registration (before authentication)
      allow read, write: if true;
    }

    // Conversations collection
    match /conversations/{conversationId} {
      allow read, create, update: if request.auth != null && (
        // Allow if user is in participants (for existing conversations)
        (resource != null && resource.data != null && request.auth.uid in resource.data.participants) ||
        // Allow if being created and user is in participants (for new conversations)
        (request.resource != null && request.resource.data != null && request.auth.uid in request.resource.data.participants) ||
        // Allow if conversation ID contains user's ID (for checking existence before creation)
        conversationId.split('_').hasAny([request.auth.uid])
      );
      
      // Messages subcollection
      match /messages/{messageId} {
        allow read: if request.auth != null && 
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        allow create: if request.auth != null &&
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        allow update: if request.auth != null && 
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
      }
    }

    // Notifications collection
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if request.auth != null && request.auth.uid == resource.data.recipientId;
      // Users can create notifications for others
      allow create: if request.auth != null && request.auth.uid == request.resource.data.senderId;
      // Users can update their own notifications (mark as read, etc.)
      allow update: if request.auth != null && request.auth.uid == resource.data.recipientId;
      // Users can delete their own notifications
      allow delete: if request.auth != null && request.auth.uid == resource.data.recipientId;
    }

    // Ride tracking collection for ride management
    match /ride_tracking/{trackingId} {
      // Allow request owner and accepted driver to create ride tracking
      allow create: if request.auth != null && (
        // Request owner can create tracking when accepting a driver response
        request.auth.uid == request.resource.data.requesterId ||
        // Driver can create tracking when their response is accepted
        request.auth.uid == request.resource.data.driverId
      );
      // Both request owner and driver can read and update tracking
      allow read, update: if request.auth != null && (
        request.auth.uid == resource.data.requesterId ||
        request.auth.uid == resource.data.driverId
      );
    }

    // Universal response tracking collection for all request types
    match /response_tracking/{trackingId} {
      // Allow request owner and responder to create tracking
      allow create: if request.auth != null && (
        // Request owner can create tracking when accepting a response
        request.auth.uid == request.resource.data.requesterId ||
        // Responder can create tracking when their response is accepted
        request.auth.uid == request.resource.data.responderId
      );
      // Both request owner and responder can read and update tracking
      allow read, update: if request.auth != null && (
        request.auth.uid == resource.data.requesterId ||
        request.auth.uid == resource.data.responderId
      );
    }

    // Product categories collection - readable by all, writable by authenticated users
    match /product_categories/{categoryId} {
      allow read: if true; // Categories are public
      allow write: if request.auth != null; // Authenticated users can manage categories via admin panel
    }

    // Master products collection - readable by all, writable by authenticated users
    match /master_products/{productId} {
      allow read: if true; // Products are public for comparison
      allow create: if request.auth != null; // Authenticated users can add products
      allow update: if request.auth != null; // Allow updates for management
      allow delete: if request.auth != null; // Allow deletion for management
    }

    // Business products collection - businesses can manage their own listings
    match /business_products/{businessProductId} {
      allow read: if true; // Product listings are public for comparison
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.businessId;
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.businessId;
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.businessId;
    }

    // Business profiles collection
    match /businesses/{businessId} {
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId;
      allow read: if true; // Business profiles are public
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.userId;
    }

    // Business verification collection
    match /business_verifications/{businessId} {
      allow create: if request.auth != null && 
        exists(/databases/$(database)/documents/businesses/$(businessId)) &&
        get(/databases/$(database)/documents/businesses/$(businessId)).data.userId == request.auth.uid;
      allow read, update: if request.auth != null && 
        exists(/databases/$(database)/documents/businesses/$(businessId)) &&
        get(/databases/$(database)/documents/businesses/$(businessId)).data.userId == request.auth.uid;
    }

    // Business email verification tokens collection
    match /business_email_verifications/{businessId} {
      allow create, read, update: if request.auth != null && 
        exists(/databases/$(database)/documents/businesses/$(businessId)) &&
        get(/databases/$(database)/documents/businesses/$(businessId)).data.userId == request.auth.uid;
    }

    // Business phone OTP verifications collection
    match /business_phone_verifications/{businessId} {
      allow create, read, update: if request.auth != null && 
        exists(/databases/$(database)/documents/businesses/$(businessId)) &&
        get(/databases/$(database)/documents/businesses/$(businessId)).data.userId == request.auth.uid;
    }

    // Product clicks collection for revenue tracking
    match /product_clicks/{clickId} {
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId;
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      // Business owners can read clicks for their products
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/business_products/$(resource.data.businessProductId)) &&
        get(/databases/$(database)/documents/business_products/$(resource.data.businessProductId)).data.businessId == request.auth.uid;
    }

    // Default deny all reads and writes - This should be the LAST rule
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
